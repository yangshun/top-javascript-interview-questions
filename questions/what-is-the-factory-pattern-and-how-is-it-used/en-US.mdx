---
title: What is the Factory pattern and how is it used?
---

## TL;DR

The Factory pattern is a design pattern used to create objects without specifying the exact class of the object that will be created. It provides a way to encapsulate the instantiation logic and can be particularly useful when the creation process is complex or when the type of object to be created is determined at runtime.

For example, in JavaScript, you can use a factory function to create different types of objects:

```js live
function createAnimal(type) {
  if (type === 'dog') {
    return { sound: 'woof' };
  } else if (type === 'cat') {
    return { sound: 'meow' };
  }
}

const dog = createAnimal('dog');
const cat = createAnimal('cat');
```

---

## What is the Factory pattern and how is it used?

### Definition

The Factory pattern is a creational design pattern that provides an interface for creating objects in a superclass but allows subclasses to alter the type of objects that will be created. It encapsulates the object creation process, making the code more modular and easier to manage.

### Use cases

1. **Complex object creation**: When the process of creating an object is complex or involves multiple steps.
2. **Runtime object determination**: When the type of object to be created is determined at runtime.
3. **Decoupling**: To decouple the client code from the specific classes it needs to instantiate.

### Implementation in JavaScript

In JavaScript, the Factory pattern can be implemented using factory functions or classes. Below are examples of both approaches.

#### Factory function

A factory function is a simple function that returns an object. It can contain logic to decide which type of object to create.

```js live
function createAnimal(type) {
  if (type === 'dog') {
    return { sound: 'woof' };
  } else if (type === 'cat') {
    return { sound: 'meow' };
  } else {
    return { sound: 'unknown' };
  }
}

const dog = createAnimal('dog');
const cat = createAnimal('cat');
console.log(dog.sound); // Output: woof
console.log(cat.sound); // Output: meow
```

#### Factory class

A factory class can be used to encapsulate the creation logic within a class structure.

```js live
class AnimalFactory {
  createAnimal(type) {
    if (type === 'dog') {
      return new Dog();
    } else if (type === 'cat') {
      return new Cat();
    } else {
      return new Animal();
    }
  }
}

class Dog {
  constructor() {
    this.sound = 'woof';
  }
}

class Cat {
  constructor() {
    this.sound = 'meow';
  }
}

class Animal {
  constructor() {
    this.sound = 'unknown';
  }
}

const factory = new AnimalFactory();
const dog = factory.createAnimal('dog');
const cat = factory.createAnimal('cat');
console.log(dog.sound); // Output: woof
console.log(cat.sound); // Output: meow
```

### Benefits

1. **Encapsulation**: The creation logic is encapsulated in one place.
2. **Flexibility**: Easy to add new types of objects without changing the client code.
3. **Decoupling**: Reduces the dependency of the client code on specific classes.

### Drawbacks

1. **Complexity**: Can add unnecessary complexity if the object creation logic is simple.
2. **Overhead**: May introduce additional overhead if not used judiciously.

## Further reading

- [Factory Method Pattern on Wikipedia](https://en.wikipedia.org/wiki/Factory_method_pattern)
- [Factory Pattern in JavaScript](https://www.dofactory.com/javascript/design-patterns/factory)
- [MDN Web Docs: Object-oriented JavaScript for beginners](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object-oriented_JS)
